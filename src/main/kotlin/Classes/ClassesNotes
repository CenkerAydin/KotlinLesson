CLASSES

Classlar parametre alabilir;
Default değer alabilirler.
Geri dönüş tipi yoktur.

Classın yanına const ekleyebilirsin ->Primary const.

class Car constructor(wheelCount:Int){

}
class Car(wheelCount:Int){

}

class sınıfının içine const ekleyebilirsin -> Secondary const.
Secondary const. sırasının önemi yok

class Car(wheelCount:Int){

    constructor():this() {

    }
}
Secondary const. mecburi olarak primary const. işaret etmek zorunda.
this:() ->Primary const. işaret eder.

bir classtan nesne oluşturmak için
val car0=Car() oluşturur.
oluşturduktan sonra primary const. içindeki parametrelerden oluşan bir parametre verdiyseniz init bloğu çalışır.
primary const. içindeki parametrelerden oluşmayan bir parametre verdiyseniz önce init sonra secondary const.lar çalışır

Javada olduğu gibi default const. kotlin dilinde de mevcut.
Primary const ve secondary const. yazmasanız bile default const. oluşur
Eğer secondary constructorın içini if case ile ayıracaksanız secondary const. overload edip if case durumlarını parametre olarak geçirebilirsiniz.
Bu şekilde daha iyi bir kod yazarsınız.
best practice olarak class ismi büyük fonksiyon ismi küçük başlat.

VISIBILITY MODIFIERS

Javada bir değişkeni herhangi bir erişim belirteci kullanmadan tanımlarsak,
default olarak package-private olur.Yani sadece aynı paket içindeki diğer sınıflardan erişilebilir.

Bu durum kotlinde farklıdır. Herhangi bir erişim belirteci kullanmadan tanımlarsak,
default olarak public olur.

private ->Sadece bağlı bulunduğu class içerisinden erişilebilir.Başka hiçbir yerden erişilemez.(Child class dahil)
public -> Her yerden erişilebilir.
protected ->Bağlı bulunduğu class ve bulunduğu classı miras alan(inheritance) classlar erişebilir sadece.
internal ->Module bazında public olur. Onun dışında her yerde private

protected kotlinde top level tanımlamalarda kullanılamaz.
top level olduğu için hiçbir zaman miras alınamaz o yüzden protected kullanılamaz.

open ve final access modifiersdır.Visibility modifiers ile karıştırma.
PROPERTY VS FIELD
Java dilinden örnek:
field -> String name="Cenk"

property ->

 public String getName(){
    return name;
}
public void setName(String name){
   this.name=name;
}

Kotlinde her şey public tutulur.Encapsulation sağlamak için değişkenler direkt property olur.
Kotlinde field değişken tanımlanmaz.
Kotlinde değişken tanımlandığında arka tarafında get ve set methodları şeklinde bir üretim yapılır.
val name="Cenk" -> direkt olarak property olur.
O yüzden kotlinde encapsulation çok sağlamdır.

Eğer  değişken public ise set fonksiyonunu private yapabilirsin ama get fonksiyonunu
private yapamazsın sebebi ise, eğer public ise her yerden erişebilirsin ama get fonksiyonu private olursa
sadece o class içinde erişilebilir olur.

INHERITANCE
Kotlinde bütün classlar default olarak final tanımlanır.
Eğer bir classı inherit almak istiyorsan o classın önünde open keywordu olması lazım.
bir classı inherit almak istiyorsanız : işaretini kullanmanız lazım.
inherit aldığın sınıftan bir classı override etmeden child classta aynı parametre,geri dönüş
şekliyle kullanamazsın.
bir class birden fazla classı inherit alamazsın.
inherit aldığın bir classın en az bir const. kullanman gerek.
Override ->fonksiyonu veya değişkeni alıp child classda farklı bir işlevde kullanmak için kullanılır.(Polymorphism ilkesi)
super keywordu ust classtaki fonksiyonu işaret eder.
Eğer override fonksiyonu üst classtaki işlevi yapmasını istiyorsanız super keywordunu kullanmanız gerekir.
Bir class başka bir classı inherit ediyorsa o classın sahip olduğu her şeyi alır.
inherit edilen classa genel olarak parent-class
inherit alan classa child-class denir.
Karmaşıklığı önlemek için kullanılır.
Bazen parent-classların sahip olduğu yetkinlikleri child-classlarda değiştirmek isteyebilirsin.(Overload)

ABSTRACT CLASS-INTERFACES
Abstractler ve interfacelerin tek başına olmaları anlamsızdır,
inherit alınmaları veya impelement edilmeleri lazım

Abstraction içselleştirerek öğrendiğinizde bir üst seviyeye çıkarsınız.
Abstract classı bir şablon gibi düşünebilirsin.
Burada final ve open modifierları kullanmak anlamsız ve yanlıştır.
Abstract olarak yazılmış classa yeni eklenen tüm abstract yapılar,
Tum child classlarda override edilmek zorundadır.
Eğer abstract classınıza eklemek istediğiniz opsiyonel yapılar varsa,bunları child classların tamamında override
etmek zorunda olmayalım diye, open keywordu ile tanımlayabiliriz.
Abstract bir class, abstract bir classı miras alırsa, abstract yapıları override etmek zorunda değildir.
Abstract fun, bodysi olmaz. Propertylerinde default değeri olmaz.
Abstract classlar aynı zamaanda instance'i oluşturulamayan classlar.
Bu sebeple singleton gibi patternler için de kullanılabiliyorlar.
abstract keywordu miras alınabilmeyi sağlar.

Eğer abstractı classı, düz bir class inherit alıyorsa tüm yapıları override etmek zorunda
Eğer abstract class override edip düz class tarafından inherit alıyorsa düz class o yapıyı override etmeyebilir.
Abstract class bir abstract class tarafından inherit alıyor tüm yapıları override etmek zorunda değilsin.

Interfaceler implement edilir.
Interfacelerin abstract classlardan en buyuk fakrı state(değeri)  tutamıyor olusları.State tutması için değerinin değiştirilmesi gerekir.
Property initializers are not allowed in interfaces
Interface içerisindeki initial değeri olmayan bir property(fiedl) ya da bodysi olmayan bir fonksiyon
abstract olarak da tanımlanabilir.
Interfaceleri anlamı gereği final yapamazsınız.Open yazılması gereksizdir.(Redundant)
